"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""Defined a Subgraph ID for an object type"""
directive @subgraphId(id: String!) on OBJECT

"Vault allocator\n"
type Allocator {
  """The allocator's address"""
  address: Bytes!

  """<Vault ID>-<Allocator address>"""
  id: ID!

  """The allocator's shares amount"""
  shares: BigInt!

  """The vault of the allocator"""
  vault: Vault!
}

"Allocator action\n"
type AllocatorAction {
  """The type of the action"""
  actionType: AllocatorActionType!

  """The allocator's address"""
  address: Bytes!

  """The amount of action's assets"""
  assets: BigInt

  """The timestamp the action was created at"""
  createdAt: BigInt!

  """Set to `transaction hash-log index`"""
  id: ID!

  """The amount of action's shares"""
  shares: BigInt

  """The allocator's vault"""
  vault: Vault!
}

enum AllocatorActionType {
  Deposit
  ExitQueueEntered
  ExitedAssetsClaimed
  Redeem
  VaultCreation
}

input AllocatorAction_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  actionType: AllocatorActionType
  actionType_in: [AllocatorActionType!]
  actionType_not: AllocatorActionType
  actionType_not_in: [AllocatorActionType!]
  address: Bytes
  address_contains: Bytes
  address_gt: Bytes
  address_gte: Bytes
  address_in: [Bytes!]
  address_lt: Bytes
  address_lte: Bytes
  address_not: Bytes
  address_not_contains: Bytes
  address_not_in: [Bytes!]
  and: [AllocatorAction_filter]
  assets: BigInt
  assets_gt: BigInt
  assets_gte: BigInt
  assets_in: [BigInt!]
  assets_lt: BigInt
  assets_lte: BigInt
  assets_not: BigInt
  assets_not_in: [BigInt!]
  createdAt: BigInt
  createdAt_gt: BigInt
  createdAt_gte: BigInt
  createdAt_in: [BigInt!]
  createdAt_lt: BigInt
  createdAt_lte: BigInt
  createdAt_not: BigInt
  createdAt_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [AllocatorAction_filter]
  shares: BigInt
  shares_gt: BigInt
  shares_gte: BigInt
  shares_in: [BigInt!]
  shares_lt: BigInt
  shares_lte: BigInt
  shares_not: BigInt
  shares_not_in: [BigInt!]
  vault: String
  vault_: Vault_filter
  vault_contains: String
  vault_contains_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_gt: String
  vault_gte: String
  vault_in: [String!]
  vault_lt: String
  vault_lte: String
  vault_not: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_not_in: [String!]
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
}

enum AllocatorAction_orderBy {
  actionType
  address
  assets
  createdAt
  id
  shares
  vault
  vault__addressString
  vault__admin
  vault__avgRewardPerAsset
  vault__capacity
  vault__createdAt
  vault__description
  vault__displayName
  vault__factory
  vault__feePercent
  vault__feeRecipient
  vault__id
  vault__imageUrl
  vault__isPrivate
  vault__lockedMevReward
  vault__metadataIpfsHash
  vault__metadataUpdatedAt
  vault__mevEscrow
  vault__operator
  vault__principalAssets
  vault__proofReward
  vault__proofUnlockedMevReward
  vault__queuedShares
  vault__rewardsIpfsHash
  vault__rewardsRoot
  vault__rewardsTimestamp
  vault__score
  vault__tokenName
  vault__tokenSymbol
  vault__totalAssets
  vault__totalShares
  vault__unclaimedAssets
  vault__validatorsRoot
  vault__whitelister
}

input Allocator_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  address: Bytes
  address_contains: Bytes
  address_gt: Bytes
  address_gte: Bytes
  address_in: [Bytes!]
  address_lt: Bytes
  address_lte: Bytes
  address_not: Bytes
  address_not_contains: Bytes
  address_not_in: [Bytes!]
  and: [Allocator_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [Allocator_filter]
  shares: BigInt
  shares_gt: BigInt
  shares_gte: BigInt
  shares_in: [BigInt!]
  shares_lt: BigInt
  shares_lte: BigInt
  shares_not: BigInt
  shares_not_in: [BigInt!]
  vault: String
  vault_: Vault_filter
  vault_contains: String
  vault_contains_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_gt: String
  vault_gte: String
  vault_in: [String!]
  vault_lt: String
  vault_lte: String
  vault_not: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_not_in: [String!]
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
}

enum Allocator_orderBy {
  address
  id
  shares
  vault
  vault__addressString
  vault__admin
  vault__avgRewardPerAsset
  vault__capacity
  vault__createdAt
  vault__description
  vault__displayName
  vault__factory
  vault__feePercent
  vault__feeRecipient
  vault__id
  vault__imageUrl
  vault__isPrivate
  vault__lockedMevReward
  vault__metadataIpfsHash
  vault__metadataUpdatedAt
  vault__mevEscrow
  vault__operator
  vault__principalAssets
  vault__proofReward
  vault__proofUnlockedMevReward
  vault__queuedShares
  vault__rewardsIpfsHash
  vault__rewardsRoot
  vault__rewardsTimestamp
  vault__score
  vault__tokenName
  vault__tokenSymbol
  vault__totalAssets
  vault__totalShares
  vault__unclaimedAssets
  vault__validatorsRoot
  vault__whitelister
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type DaySnapshot {
  """The timestamp rounded to current day by dividing by 86400"""
  date: Int!

  """<Vault ID>-<date>"""
  id: ID!

  """The reward on one asset"""
  rewardPerAsset: BigDecimal!

  """The total number of assets"""
  totalAssets: BigInt!

  """The snapshot's vault"""
  vault: Vault!
}

input DaySnapshot_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [DaySnapshot_filter]
  date: Int
  date_gt: Int
  date_gte: Int
  date_in: [Int!]
  date_lt: Int
  date_lte: Int
  date_not: Int
  date_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [DaySnapshot_filter]
  rewardPerAsset: BigDecimal
  rewardPerAsset_gt: BigDecimal
  rewardPerAsset_gte: BigDecimal
  rewardPerAsset_in: [BigDecimal!]
  rewardPerAsset_lt: BigDecimal
  rewardPerAsset_lte: BigDecimal
  rewardPerAsset_not: BigDecimal
  rewardPerAsset_not_in: [BigDecimal!]
  totalAssets: BigInt
  totalAssets_gt: BigInt
  totalAssets_gte: BigInt
  totalAssets_in: [BigInt!]
  totalAssets_lt: BigInt
  totalAssets_lte: BigInt
  totalAssets_not: BigInt
  totalAssets_not_in: [BigInt!]
  vault: String
  vault_: Vault_filter
  vault_contains: String
  vault_contains_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_gt: String
  vault_gte: String
  vault_in: [String!]
  vault_lt: String
  vault_lte: String
  vault_not: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_not_in: [String!]
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
}

enum DaySnapshot_orderBy {
  date
  id
  rewardPerAsset
  totalAssets
  vault
  vault__addressString
  vault__admin
  vault__avgRewardPerAsset
  vault__capacity
  vault__createdAt
  vault__description
  vault__displayName
  vault__factory
  vault__feePercent
  vault__feeRecipient
  vault__id
  vault__imageUrl
  vault__isPrivate
  vault__lockedMevReward
  vault__metadataIpfsHash
  vault__metadataUpdatedAt
  vault__mevEscrow
  vault__operator
  vault__principalAssets
  vault__proofReward
  vault__proofUnlockedMevReward
  vault__queuedShares
  vault__rewardsIpfsHash
  vault__rewardsRoot
  vault__rewardsTimestamp
  vault__score
  vault__tokenName
  vault__tokenSymbol
  vault__totalAssets
  vault__totalShares
  vault__unclaimedAssets
  vault__validatorsRoot
  vault__whitelister
}

"Vault exit request\n"
type ExitRequest {
  """<Vault ID>-<Exit queue id>"""
  id: ID!

  """The exiting shares owner"""
  owner: Bytes!

  """The exit queue position counter"""
  positionCounter: BigInt!

  """The exited assets receiver"""
  receiver: Bytes!

  """The number of shares queued for exit"""
  totalShares: BigInt!

  """The exit request vault"""
  vault: Vault!
}

input ExitRequest_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ExitRequest_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [ExitRequest_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  positionCounter: BigInt
  positionCounter_gt: BigInt
  positionCounter_gte: BigInt
  positionCounter_in: [BigInt!]
  positionCounter_lt: BigInt
  positionCounter_lte: BigInt
  positionCounter_not: BigInt
  positionCounter_not_in: [BigInt!]
  receiver: Bytes
  receiver_contains: Bytes
  receiver_gt: Bytes
  receiver_gte: Bytes
  receiver_in: [Bytes!]
  receiver_lt: Bytes
  receiver_lte: Bytes
  receiver_not: Bytes
  receiver_not_contains: Bytes
  receiver_not_in: [Bytes!]
  totalShares: BigInt
  totalShares_gt: BigInt
  totalShares_gte: BigInt
  totalShares_in: [BigInt!]
  totalShares_lt: BigInt
  totalShares_lte: BigInt
  totalShares_not: BigInt
  totalShares_not_in: [BigInt!]
  vault: String
  vault_: Vault_filter
  vault_contains: String
  vault_contains_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_gt: String
  vault_gte: String
  vault_in: [String!]
  vault_lt: String
  vault_lte: String
  vault_not: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_not_in: [String!]
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
}

enum ExitRequest_orderBy {
  id
  owner
  positionCounter
  receiver
  totalShares
  vault
  vault__addressString
  vault__admin
  vault__avgRewardPerAsset
  vault__capacity
  vault__createdAt
  vault__description
  vault__displayName
  vault__factory
  vault__feePercent
  vault__feeRecipient
  vault__id
  vault__imageUrl
  vault__isPrivate
  vault__lockedMevReward
  vault__metadataIpfsHash
  vault__metadataUpdatedAt
  vault__mevEscrow
  vault__operator
  vault__principalAssets
  vault__proofReward
  vault__proofUnlockedMevReward
  vault__queuedShares
  vault__rewardsIpfsHash
  vault__rewardsRoot
  vault__rewardsTimestamp
  vault__score
  vault__tokenName
  vault__tokenSymbol
  vault__totalAssets
  vault__totalShares
  vault__unclaimedAssets
  vault__validatorsRoot
  vault__whitelister
}

"Network data\n"
type Network {
  """Always 0"""
  id: ID!

  """Total vaults"""
  vaultsTotal: Int!
}

input Network_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Network_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [Network_filter]
  vaultsTotal: Int
  vaultsTotal_gt: Int
  vaultsTotal_gte: Int
  vaultsTotal_in: [Int!]
  vaultsTotal_lt: Int
  vaultsTotal_lte: Int
  vaultsTotal_not: Int
  vaultsTotal_not_in: [Int!]
}

enum Network_orderBy {
  id
  vaultsTotal
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

"Account that is whitelisted in the private Vault\n"
type PrivateVaultAccount {
  """The address of the account"""
  address: Bytes!

  """The timestamp when the account was added"""
  createdAt: BigInt!

  """<Vault ID>-<address>"""
  id: ID!

  """The private Vault"""
  vault: Vault!
}

input PrivateVaultAccount_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  address: Bytes
  address_contains: Bytes
  address_gt: Bytes
  address_gte: Bytes
  address_in: [Bytes!]
  address_lt: Bytes
  address_lte: Bytes
  address_not: Bytes
  address_not_contains: Bytes
  address_not_in: [Bytes!]
  and: [PrivateVaultAccount_filter]
  createdAt: BigInt
  createdAt_gt: BigInt
  createdAt_gte: BigInt
  createdAt_in: [BigInt!]
  createdAt_lt: BigInt
  createdAt_lte: BigInt
  createdAt_not: BigInt
  createdAt_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [PrivateVaultAccount_filter]
  vault: String
  vault_: Vault_filter
  vault_contains: String
  vault_contains_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_gt: String
  vault_gte: String
  vault_in: [String!]
  vault_lt: String
  vault_lte: String
  vault_not: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_not_in: [String!]
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
}

enum PrivateVaultAccount_orderBy {
  address
  createdAt
  id
  vault
  vault__addressString
  vault__admin
  vault__avgRewardPerAsset
  vault__capacity
  vault__createdAt
  vault__description
  vault__displayName
  vault__factory
  vault__feePercent
  vault__feeRecipient
  vault__id
  vault__imageUrl
  vault__isPrivate
  vault__lockedMevReward
  vault__metadataIpfsHash
  vault__metadataUpdatedAt
  vault__mevEscrow
  vault__operator
  vault__principalAssets
  vault__proofReward
  vault__proofUnlockedMevReward
  vault__queuedShares
  vault__rewardsIpfsHash
  vault__rewardsRoot
  vault__rewardsTimestamp
  vault__score
  vault__tokenName
  vault__tokenSymbol
  vault__totalAssets
  vault__totalShares
  vault__unclaimedAssets
  vault__validatorsRoot
  vault__whitelister
}

type Query {
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  allocator(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Allocator
  allocatorAction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AllocatorAction
  allocatorActions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AllocatorAction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AllocatorAction_filter
  ): [AllocatorAction!]!
  allocators(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Allocator_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Allocator_filter
  ): [Allocator!]!
  daySnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DaySnapshot
  daySnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DaySnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DaySnapshot_filter
  ): [DaySnapshot!]!
  exitRequest(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ExitRequest
  exitRequests(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ExitRequest_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ExitRequest_filter
  ): [ExitRequest!]!
  network(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Network
  networks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Network_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Network_filter
  ): [Network!]!
  privateVaultAccount(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PrivateVaultAccount
  privateVaultAccounts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PrivateVaultAccount_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PrivateVaultAccount_filter
  ): [PrivateVaultAccount!]!
  transaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transaction
  transactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Transaction_filter
  ): [Transaction!]!
  vault(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Vault
  vaults(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Vault_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Vault_filter
  ): [Vault!]!
}

type Subscription {
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  allocator(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Allocator
  allocatorAction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AllocatorAction
  allocatorActions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AllocatorAction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AllocatorAction_filter
  ): [AllocatorAction!]!
  allocators(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Allocator_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Allocator_filter
  ): [Allocator!]!
  daySnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DaySnapshot
  daySnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DaySnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DaySnapshot_filter
  ): [DaySnapshot!]!
  exitRequest(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ExitRequest
  exitRequests(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ExitRequest_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ExitRequest_filter
  ): [ExitRequest!]!
  network(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Network
  networks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Network_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Network_filter
  ): [Network!]!
  privateVaultAccount(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PrivateVaultAccount
  privateVaultAccounts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PrivateVaultAccount_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PrivateVaultAccount_filter
  ): [PrivateVaultAccount!]!
  transaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transaction
  transactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Transaction_filter
  ): [Transaction!]!
  vault(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Vault
  vaults(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Vault_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Vault_filter
  ): [Vault!]!
}

"StakeWise V3 transaction\n"
type Transaction {
  """Transaction hash"""
  id: ID!
}

input Transaction_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Transaction_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [Transaction_filter]
}

enum Transaction_orderBy {
  id
}

"Vault\n"
type Vault {
  """Vault address string for search"""
  addressString: String!

  """The address of the vault admin"""
  admin: Bytes!

  """The vault allocators' actions"""
  allocatorActions(first: Int = 100, orderBy: AllocatorAction_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: AllocatorAction_filter): [AllocatorAction!]!

  """The vault allocators"""
  allocators(first: Int = 100, orderBy: Allocator_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Allocator_filter): [Allocator!]!

  """Average reward on one asset"""
  avgRewardPerAsset: BigDecimal!

  """The max total assets that can be allocated into the vault"""
  capacity: BigInt!

  """The timestamp the vault was created at"""
  createdAt: BigInt!

  """The vault day snapshots"""
  daySnapshots(first: Int = 100, orderBy: DaySnapshot_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: DaySnapshot_filter): [DaySnapshot!]!

  """The optional description extracted from metadata IPFS file"""
  description: String

  """The optional vault name extracted from metadata IPFS file"""
  displayName: String

  """The vault exit requests"""
  exitRequests(first: Int = 100, orderBy: ExitRequest_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: ExitRequest_filter): [ExitRequest!]!

  """The address of the factory used to create vault"""
  factory: Bytes!

  """The staking fee percent charged by the vault"""
  feePercent: Int!

  """The address of the vault's fee recipient"""
  feeRecipient: Bytes!

  """Vault address"""
  id: ID!

  """The optional image URL extracted from metadata IPFS file"""
  imageUrl: String

  """Indicates whether the Vault is private"""
  isPrivate: Boolean!

  """The vault locked MEV reward"""
  lockedMevReward: BigInt

  """The vault metadata IPFS hash"""
  metadataIpfsHash: String

  """The timestamp the metadata was updated at"""
  metadataUpdatedAt: BigInt

  """
  The MEV and priority fees escrow address. If it's null, then the vault uses shared MEV escrow.
  """
  mevEscrow: Bytes

  """The address of the vault's operator"""
  operator: Bytes!

  """The number of assets used for rewardPerAsset calculation"""
  principalAssets: BigInt!

  """The vault rewards root proof used to submit state update proof"""
  proof: [String!]

  """The vault reward used to submit state update proof"""
  proofReward: BigInt

  """The vault unlocked MEV reward used to submit state update proof"""
  proofUnlockedMevReward: BigInt

  """The number of shares queued for the exit"""
  queuedShares: BigInt!

  """The vault rewards IPFS hash"""
  rewardsIpfsHash: String

  """The vault rewards root"""
  rewardsRoot: Bytes

  """The last vault rewards update timestamp"""
  rewardsTimestamp: BigInt

  """The vault score"""
  score: BigDecimal!

  """The vault token name"""
  tokenName: String!

  """The vault token symbol"""
  tokenSymbol: String!

  """The total number of assets"""
  totalAssets: BigInt!

  """The total number of shares"""
  totalShares: BigInt!

  """The number of assets that are waiting to be claimed after exit"""
  unclaimedAssets: BigInt!

  """The vault validators merkle tree root"""
  validatorsRoot: Bytes

  """If the Vault is private, whitelister can add/remove allocators"""
  whitelister: Bytes
}

input Vault_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  addressString: String
  addressString_contains: String
  addressString_contains_nocase: String
  addressString_ends_with: String
  addressString_ends_with_nocase: String
  addressString_gt: String
  addressString_gte: String
  addressString_in: [String!]
  addressString_lt: String
  addressString_lte: String
  addressString_not: String
  addressString_not_contains: String
  addressString_not_contains_nocase: String
  addressString_not_ends_with: String
  addressString_not_ends_with_nocase: String
  addressString_not_in: [String!]
  addressString_not_starts_with: String
  addressString_not_starts_with_nocase: String
  addressString_starts_with: String
  addressString_starts_with_nocase: String
  admin: Bytes
  admin_contains: Bytes
  admin_gt: Bytes
  admin_gte: Bytes
  admin_in: [Bytes!]
  admin_lt: Bytes
  admin_lte: Bytes
  admin_not: Bytes
  admin_not_contains: Bytes
  admin_not_in: [Bytes!]
  allocatorActions_: AllocatorAction_filter
  allocators_: Allocator_filter
  and: [Vault_filter]
  avgRewardPerAsset: BigDecimal
  avgRewardPerAsset_gt: BigDecimal
  avgRewardPerAsset_gte: BigDecimal
  avgRewardPerAsset_in: [BigDecimal!]
  avgRewardPerAsset_lt: BigDecimal
  avgRewardPerAsset_lte: BigDecimal
  avgRewardPerAsset_not: BigDecimal
  avgRewardPerAsset_not_in: [BigDecimal!]
  capacity: BigInt
  capacity_gt: BigInt
  capacity_gte: BigInt
  capacity_in: [BigInt!]
  capacity_lt: BigInt
  capacity_lte: BigInt
  capacity_not: BigInt
  capacity_not_in: [BigInt!]
  createdAt: BigInt
  createdAt_gt: BigInt
  createdAt_gte: BigInt
  createdAt_in: [BigInt!]
  createdAt_lt: BigInt
  createdAt_lte: BigInt
  createdAt_not: BigInt
  createdAt_not_in: [BigInt!]
  daySnapshots_: DaySnapshot_filter
  description: String
  description_contains: String
  description_contains_nocase: String
  description_ends_with: String
  description_ends_with_nocase: String
  description_gt: String
  description_gte: String
  description_in: [String!]
  description_lt: String
  description_lte: String
  description_not: String
  description_not_contains: String
  description_not_contains_nocase: String
  description_not_ends_with: String
  description_not_ends_with_nocase: String
  description_not_in: [String!]
  description_not_starts_with: String
  description_not_starts_with_nocase: String
  description_starts_with: String
  description_starts_with_nocase: String
  displayName: String
  displayName_contains: String
  displayName_contains_nocase: String
  displayName_ends_with: String
  displayName_ends_with_nocase: String
  displayName_gt: String
  displayName_gte: String
  displayName_in: [String!]
  displayName_lt: String
  displayName_lte: String
  displayName_not: String
  displayName_not_contains: String
  displayName_not_contains_nocase: String
  displayName_not_ends_with: String
  displayName_not_ends_with_nocase: String
  displayName_not_in: [String!]
  displayName_not_starts_with: String
  displayName_not_starts_with_nocase: String
  displayName_starts_with: String
  displayName_starts_with_nocase: String
  exitRequests_: ExitRequest_filter
  factory: Bytes
  factory_contains: Bytes
  factory_gt: Bytes
  factory_gte: Bytes
  factory_in: [Bytes!]
  factory_lt: Bytes
  factory_lte: Bytes
  factory_not: Bytes
  factory_not_contains: Bytes
  factory_not_in: [Bytes!]
  feePercent: Int
  feePercent_gt: Int
  feePercent_gte: Int
  feePercent_in: [Int!]
  feePercent_lt: Int
  feePercent_lte: Int
  feePercent_not: Int
  feePercent_not_in: [Int!]
  feeRecipient: Bytes
  feeRecipient_contains: Bytes
  feeRecipient_gt: Bytes
  feeRecipient_gte: Bytes
  feeRecipient_in: [Bytes!]
  feeRecipient_lt: Bytes
  feeRecipient_lte: Bytes
  feeRecipient_not: Bytes
  feeRecipient_not_contains: Bytes
  feeRecipient_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  imageUrl: String
  imageUrl_contains: String
  imageUrl_contains_nocase: String
  imageUrl_ends_with: String
  imageUrl_ends_with_nocase: String
  imageUrl_gt: String
  imageUrl_gte: String
  imageUrl_in: [String!]
  imageUrl_lt: String
  imageUrl_lte: String
  imageUrl_not: String
  imageUrl_not_contains: String
  imageUrl_not_contains_nocase: String
  imageUrl_not_ends_with: String
  imageUrl_not_ends_with_nocase: String
  imageUrl_not_in: [String!]
  imageUrl_not_starts_with: String
  imageUrl_not_starts_with_nocase: String
  imageUrl_starts_with: String
  imageUrl_starts_with_nocase: String
  isPrivate: Boolean
  isPrivate_in: [Boolean!]
  isPrivate_not: Boolean
  isPrivate_not_in: [Boolean!]
  lockedMevReward: BigInt
  lockedMevReward_gt: BigInt
  lockedMevReward_gte: BigInt
  lockedMevReward_in: [BigInt!]
  lockedMevReward_lt: BigInt
  lockedMevReward_lte: BigInt
  lockedMevReward_not: BigInt
  lockedMevReward_not_in: [BigInt!]
  metadataIpfsHash: String
  metadataIpfsHash_contains: String
  metadataIpfsHash_contains_nocase: String
  metadataIpfsHash_ends_with: String
  metadataIpfsHash_ends_with_nocase: String
  metadataIpfsHash_gt: String
  metadataIpfsHash_gte: String
  metadataIpfsHash_in: [String!]
  metadataIpfsHash_lt: String
  metadataIpfsHash_lte: String
  metadataIpfsHash_not: String
  metadataIpfsHash_not_contains: String
  metadataIpfsHash_not_contains_nocase: String
  metadataIpfsHash_not_ends_with: String
  metadataIpfsHash_not_ends_with_nocase: String
  metadataIpfsHash_not_in: [String!]
  metadataIpfsHash_not_starts_with: String
  metadataIpfsHash_not_starts_with_nocase: String
  metadataIpfsHash_starts_with: String
  metadataIpfsHash_starts_with_nocase: String
  metadataUpdatedAt: BigInt
  metadataUpdatedAt_gt: BigInt
  metadataUpdatedAt_gte: BigInt
  metadataUpdatedAt_in: [BigInt!]
  metadataUpdatedAt_lt: BigInt
  metadataUpdatedAt_lte: BigInt
  metadataUpdatedAt_not: BigInt
  metadataUpdatedAt_not_in: [BigInt!]
  mevEscrow: Bytes
  mevEscrow_contains: Bytes
  mevEscrow_gt: Bytes
  mevEscrow_gte: Bytes
  mevEscrow_in: [Bytes!]
  mevEscrow_lt: Bytes
  mevEscrow_lte: Bytes
  mevEscrow_not: Bytes
  mevEscrow_not_contains: Bytes
  mevEscrow_not_in: [Bytes!]
  operator: Bytes
  operator_contains: Bytes
  operator_gt: Bytes
  operator_gte: Bytes
  operator_in: [Bytes!]
  operator_lt: Bytes
  operator_lte: Bytes
  operator_not: Bytes
  operator_not_contains: Bytes
  operator_not_in: [Bytes!]
  or: [Vault_filter]
  principalAssets: BigInt
  principalAssets_gt: BigInt
  principalAssets_gte: BigInt
  principalAssets_in: [BigInt!]
  principalAssets_lt: BigInt
  principalAssets_lte: BigInt
  principalAssets_not: BigInt
  principalAssets_not_in: [BigInt!]
  proof: [String!]
  proofReward: BigInt
  proofReward_gt: BigInt
  proofReward_gte: BigInt
  proofReward_in: [BigInt!]
  proofReward_lt: BigInt
  proofReward_lte: BigInt
  proofReward_not: BigInt
  proofReward_not_in: [BigInt!]
  proofUnlockedMevReward: BigInt
  proofUnlockedMevReward_gt: BigInt
  proofUnlockedMevReward_gte: BigInt
  proofUnlockedMevReward_in: [BigInt!]
  proofUnlockedMevReward_lt: BigInt
  proofUnlockedMevReward_lte: BigInt
  proofUnlockedMevReward_not: BigInt
  proofUnlockedMevReward_not_in: [BigInt!]
  proof_contains: [String!]
  proof_contains_nocase: [String!]
  proof_not: [String!]
  proof_not_contains: [String!]
  proof_not_contains_nocase: [String!]
  queuedShares: BigInt
  queuedShares_gt: BigInt
  queuedShares_gte: BigInt
  queuedShares_in: [BigInt!]
  queuedShares_lt: BigInt
  queuedShares_lte: BigInt
  queuedShares_not: BigInt
  queuedShares_not_in: [BigInt!]
  rewardsIpfsHash: String
  rewardsIpfsHash_contains: String
  rewardsIpfsHash_contains_nocase: String
  rewardsIpfsHash_ends_with: String
  rewardsIpfsHash_ends_with_nocase: String
  rewardsIpfsHash_gt: String
  rewardsIpfsHash_gte: String
  rewardsIpfsHash_in: [String!]
  rewardsIpfsHash_lt: String
  rewardsIpfsHash_lte: String
  rewardsIpfsHash_not: String
  rewardsIpfsHash_not_contains: String
  rewardsIpfsHash_not_contains_nocase: String
  rewardsIpfsHash_not_ends_with: String
  rewardsIpfsHash_not_ends_with_nocase: String
  rewardsIpfsHash_not_in: [String!]
  rewardsIpfsHash_not_starts_with: String
  rewardsIpfsHash_not_starts_with_nocase: String
  rewardsIpfsHash_starts_with: String
  rewardsIpfsHash_starts_with_nocase: String
  rewardsRoot: Bytes
  rewardsRoot_contains: Bytes
  rewardsRoot_gt: Bytes
  rewardsRoot_gte: Bytes
  rewardsRoot_in: [Bytes!]
  rewardsRoot_lt: Bytes
  rewardsRoot_lte: Bytes
  rewardsRoot_not: Bytes
  rewardsRoot_not_contains: Bytes
  rewardsRoot_not_in: [Bytes!]
  rewardsTimestamp: BigInt
  rewardsTimestamp_gt: BigInt
  rewardsTimestamp_gte: BigInt
  rewardsTimestamp_in: [BigInt!]
  rewardsTimestamp_lt: BigInt
  rewardsTimestamp_lte: BigInt
  rewardsTimestamp_not: BigInt
  rewardsTimestamp_not_in: [BigInt!]
  score: BigDecimal
  score_gt: BigDecimal
  score_gte: BigDecimal
  score_in: [BigDecimal!]
  score_lt: BigDecimal
  score_lte: BigDecimal
  score_not: BigDecimal
  score_not_in: [BigDecimal!]
  tokenName: String
  tokenName_contains: String
  tokenName_contains_nocase: String
  tokenName_ends_with: String
  tokenName_ends_with_nocase: String
  tokenName_gt: String
  tokenName_gte: String
  tokenName_in: [String!]
  tokenName_lt: String
  tokenName_lte: String
  tokenName_not: String
  tokenName_not_contains: String
  tokenName_not_contains_nocase: String
  tokenName_not_ends_with: String
  tokenName_not_ends_with_nocase: String
  tokenName_not_in: [String!]
  tokenName_not_starts_with: String
  tokenName_not_starts_with_nocase: String
  tokenName_starts_with: String
  tokenName_starts_with_nocase: String
  tokenSymbol: String
  tokenSymbol_contains: String
  tokenSymbol_contains_nocase: String
  tokenSymbol_ends_with: String
  tokenSymbol_ends_with_nocase: String
  tokenSymbol_gt: String
  tokenSymbol_gte: String
  tokenSymbol_in: [String!]
  tokenSymbol_lt: String
  tokenSymbol_lte: String
  tokenSymbol_not: String
  tokenSymbol_not_contains: String
  tokenSymbol_not_contains_nocase: String
  tokenSymbol_not_ends_with: String
  tokenSymbol_not_ends_with_nocase: String
  tokenSymbol_not_in: [String!]
  tokenSymbol_not_starts_with: String
  tokenSymbol_not_starts_with_nocase: String
  tokenSymbol_starts_with: String
  tokenSymbol_starts_with_nocase: String
  totalAssets: BigInt
  totalAssets_gt: BigInt
  totalAssets_gte: BigInt
  totalAssets_in: [BigInt!]
  totalAssets_lt: BigInt
  totalAssets_lte: BigInt
  totalAssets_not: BigInt
  totalAssets_not_in: [BigInt!]
  totalShares: BigInt
  totalShares_gt: BigInt
  totalShares_gte: BigInt
  totalShares_in: [BigInt!]
  totalShares_lt: BigInt
  totalShares_lte: BigInt
  totalShares_not: BigInt
  totalShares_not_in: [BigInt!]
  unclaimedAssets: BigInt
  unclaimedAssets_gt: BigInt
  unclaimedAssets_gte: BigInt
  unclaimedAssets_in: [BigInt!]
  unclaimedAssets_lt: BigInt
  unclaimedAssets_lte: BigInt
  unclaimedAssets_not: BigInt
  unclaimedAssets_not_in: [BigInt!]
  validatorsRoot: Bytes
  validatorsRoot_contains: Bytes
  validatorsRoot_gt: Bytes
  validatorsRoot_gte: Bytes
  validatorsRoot_in: [Bytes!]
  validatorsRoot_lt: Bytes
  validatorsRoot_lte: Bytes
  validatorsRoot_not: Bytes
  validatorsRoot_not_contains: Bytes
  validatorsRoot_not_in: [Bytes!]
  whitelister: Bytes
  whitelister_contains: Bytes
  whitelister_gt: Bytes
  whitelister_gte: Bytes
  whitelister_in: [Bytes!]
  whitelister_lt: Bytes
  whitelister_lte: Bytes
  whitelister_not: Bytes
  whitelister_not_contains: Bytes
  whitelister_not_in: [Bytes!]
}

enum Vault_orderBy {
  addressString
  admin
  allocatorActions
  allocators
  avgRewardPerAsset
  capacity
  createdAt
  daySnapshots
  description
  displayName
  exitRequests
  factory
  feePercent
  feeRecipient
  id
  imageUrl
  isPrivate
  lockedMevReward
  metadataIpfsHash
  metadataUpdatedAt
  mevEscrow
  operator
  principalAssets
  proof
  proofReward
  proofUnlockedMevReward
  queuedShares
  rewardsIpfsHash
  rewardsRoot
  rewardsTimestamp
  score
  tokenName
  tokenSymbol
  totalAssets
  totalShares
  unclaimedAssets
  validatorsRoot
  whitelister
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes

  """The block number"""
  number: Int!

  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  "Information about a specific subgraph block. The hash of the block\nwill be null if the _meta field has a block constraint that asks for\na block number. It will be filled if the _meta field has no block constraint\nand therefore asks for the latest  block\n"
  block: _Block_!

  """The deployment ID"""
  deployment: String!

  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}